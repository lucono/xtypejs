<section id="overview-screen-content" class="screen-content" template-artifact="overview">
    
    <div class="screen-content-links">
        <div class="description-pane">
            <div>
                <span class="title">What</span>
                {{libDescription}}
            </div>
            <div>
                <span class="title">Why</span>
                Improves efficiency and readability by unifying the most basic but common data and type validations in apps into single, highly optimized operations.
            </div>
            <div>
                <span class="title">How</span>
                Employs bitwise operations, data pre-processing, and memory-efficient memoization for fast, robust performance in small and large apps and libraries.
            </div>
        </div>
    </div>
    
    <div class="code-comparison"
        data-ng-repeat="codeSnippets in [codeContent]">
        
        <div class="code-entry" id="before_code">
            
            <code-snippet
                code-item="codeSnippets.before"
                skip-compact-view>
            </code-snippet>
            
            <div class="compare-label">
                <span>
                    <a screen-link=":before_code" class="large">go</a>
                </span>
                <span>from this..</span>
                <i class="fa fa-share fa-2x fa-rotate-180"></i>
            </div>
        </div>
        
        <div class="code-entry right" id="after_code">
            <div class="compare-label">
                <span>
                    <a screen-link=":after_code" class="large">..to</a>
                </span>
                <span>concise</span>
                <span>performant</span>
                <span>readable</span>
                <span>validation</span>
                <i class="fa fa-reply fa-2x fa-rotate-180"></i>
            </div>
            
            <code-snippet 
                code-item="codeSnippets.after" 
                default-view="compact" 
                compact-view-label="Compact Names"
                default-view-label="Descriptive Names"
                info-label="Choose name scheme &nbsp; &rarr;">
            </code-snippet>
        </div>
        
        <div class="code-entry right" id="add_your_own">
            
            <div class="compare-label">
                <span>
                    <a screen-link=":add_your_own" class="large">and,</a>
                </span>
                <span>even add custom</span>
                <span>validation types</span>
                <span>of your own</span>
            </div>
            
            <code-snippet 
                code-item="codeSnippets.add_your_own" 
                default-view="compact" 
                compact-view-label="Compact Names"
                default-view-label="Descriptive Names"
                info-label="Choose name scheme &nbsp; &rarr;">
            </code-snippet>
        </div>
    </div>
    
    <div ui-view></div> <!-- dummy child view -->
    
</section>

<content-wrapper code-artifact="overview">


<content name="before_code">

function searchEmployees(value) {
    if (typeof value === 'string') {
         if (value.trim().length > 1) {
            return EmployeeDB.searchByName(value);
        } else if (value.trim().length === 1) {
            return EmployeeDB.searchByMiddleInitial(value);
        } else {
            return { error: 'Invalid search value supplied' };
        }
    } else if (typeof value === 'object' && value !== null) {
        if (Object.keys(value).length === 1) {
            return EmployeeDB.searchByFieldValuePair(value);
        } else if (Object.keys(value).length > 1) {
            return { error: 'Search by multiple fields not supported' };
        } else {
            return { error: 'Invalid search value supplied' };
        }
    } else if (typeof value === 'number') {
        if (!isNaN(value) && isFinite(value) && value > 0 && value % 1 === 0) {
            return EmployeeDB.searchByEmployeeNumber(value);
        } else {
            return { error: 'Invalid employee number supplied' };
        }
    } else if (typeof value === 'undefined' || value === null) {
        return { error: 'No search value supplied' };
    } else {
        return { error: 'Invalid search value supplied' };
    }
}
</content>


<content name="after_code">

function searchEmployees(value) {
    switch (xtype.which(value, '{{multi_char_string, single_char_string, positive_integer, single_prop_object, multi_prop_object, number, nothing}}')) {
        case '{multi_char_string}':
            return EmployeeDB.searchByName(value);
        case '{single_char_string}':
            return EmployeeDB.searchByMiddleInitial(value);
        case '{positive_integer}':
            return EmployeeDB.searchByEmployeeNumber(value);
        case '{single_prop_object}':
            return EmployeeDB.searchByFieldValuePair(value);
        case '{multi_prop_object}':
            return { error: 'Search by multiple fields not supported' };
        case '{number}':
            return { error: 'Invalid employee number supplied' };
        case '{nothing}':
            return { error: 'No search value supplied' };
        default:
            return { error: 'Invalid search value supplied' };
    }
}
</content>


<content name="add_your_own_code">

xtype.ext.registerType('ssn', {
    validator: function(val) {
        return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
    }
});

function searchEmployees(value) {
    switch (xtype.which(value, '{{ssn, positive_integer, multi_char_string}}')) {
        case 'ssn':
            return EmployeeDB.searchBySSN(value);
        case '{positive_integer}':
            return EmployeeDB.searchByEmployeeNumber(value);
        case '{multi_char_string}':
            return EmployeeDB.searchByName(value);
        default:
            return { error: 'Invalid search value supplied' };
    }
}
</content>

</content-wrapper>
<section id="types-screen-content" class="screen-content" template-artifact="types">
    
    <div class="screen-content-links">
        <div class="cols-4" data-ng-repeat="colGroup in colGroups">
            <div data-ng-repeat="typeGroup in colGroup">
                <h2><a screen-link=":{{typeGroup.name | lowercase}}_types">{{typeGroup.name}}</a></h2>
                <ul>
                    <li data-ng-repeat="type in typeGroup.types">
                        <a screen-link=":{{type.name}}">{{type.title || type.friendlyName}}</a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="screen-content-body">        
        <div class="colspan-70">
            
            <div id="{{typeGroup.name | lowercase}}_types" section-title="{{typeGroup.name}} Types" class="content-group" data-ng-repeat="typeGroup in typeGroups">
            
                <a screen-link=":{{typeGroup.name | lowercase}}_types" class="content-group-title">{{typeGroup.name}} Types</a>
                
                <div class="content-item"
                    data-ng-repeat="type in typeGroup.types"
                    data-ng-init="codeItem = codeContent[type.name]">
                    
                    <div id="{{type.name}}" section-title="{{type.title || type.name}}">
                        
                        <div class="item-title">
                            <a screen-link=":{{type.name}}">{{type.title || type.name}}</a>                            
                            <a screen-link=":{{type.name}}" class="title-label compact-label" data-ng-if="type.compactName"><code>{{type.compactName}}</code></a>
                        </div>
                        
                        <p class="item-description" data-ng-bind-html="type.description"></p>
                            
                        <div class="item-detail">
                            <div class="item-header">
                                <div data-ng-if="type.typeId">
                                   <span class="nowrap">type id</span>
                                   <span>
                                       <a data-ng-if="type.typeId.toLowerCase() === type.name.toLowerCase()"
                                           screen-link=":{{type.name}}" 
                                           class="type-label squeezed">
                                           <code>xtype.{{type.typeId}}</code>
                                       </a>
                                       <span data-ng-if="type.typeId.toLowerCase() !== type.name.toLowerCase()"
                                           data-ng-bind-html="type.typeId">
                                       </span>
                                   </span>
                                </div>
                                <div>
                                   <span>category</span>
                                   <span>{{type.category}} type</span>
                                </div>
                                <div>
                                   <span>derived</span>
                                   <span>{{(type.derived === true || type.derivation.length > 0) ? 'yes' : 'no'}}</span>
                                </div>
                                <div data-ng-if="AppUtils.isArray(type.derivation) ? type.derivation.length > 0 : type.derivation">
                                    <span>derivation</span>
                                    <span>
                                        <span data-ng-if="!AppUtils.isArray(type.derivation)" data-ng-bind-html="type.derivation"></span>
                                        <span data-ng-if="AppUtils.isArray(type.derivation)">
                                            <span class="type-label title">
                                                <code>Match Any:</code>
                                            </span>
                                            <a data-ng-repeat="compositeTypeName in type.derivation" 
                                                screen-link=":{{compositeTypeName}}" 
                                                class="type-label">
                                                <code>{{compositeTypeName}}</code>
                                            </a>
                                        </span>
                                    </span>
                                </div>
                            </div>
                            
                            <div class="item-subtitle" data-ng-if="codeItem.codeSamples">Example</div>
                            
                            <code-snippet code-item="codeItem" default-view="compact"></code-snippet>
                        </div>
                    </div>
                </div>
                
            </div>
        </div> 
                
        <div class="colspan-30 right-nav-container">
            <ul class="right-nav">
                <li data-ng-repeat="typeGroup in typeGroups" scroll-fixed>
                    <a screen-link=":{{typeGroup.name | lowercase}}_types">{{typeGroup.name | lowercase}}</a>
                </li>
                <li><a screen-link=":menu" class="circle-button up active"></a></li>
            </ul>
        </div>
        
    </div>
    
    <div ui-view></div> <!-- dummy child view -->
    
</section>
<content-wrapper code-artifact="types">

</content-wrapper><section id="api-screen-content" class="screen-content" template-artifact="api">
    
    <div class="screen-content-links">
        <div class="cols-4" data-ng-repeat="colGroup in colGroups">
            <div data-ng-repeat="methodGroup in colGroup">
                <h2><a screen-link=":{{methodGroup.name | lowercase}}_api">{{methodGroup.name}}</a></h2>
                <ul>
                    <li data-ng-repeat="method in methodGroup.methods" data-ng-if="!method.deprecated">
                        <a screen-link=":{{method.plainName}}" data-ng-bind-html="method.name"></a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
                            
    <div class="screen-content-body">    
        <div class="colspan-70">
            
            <div id="{{methodGroup.name | lowercase}}_api" section-title="{{methodGroup.name}} API" class="content-group" data-ng-repeat="methodGroup in methodGroups">
                
                <a screen-link=":{{methodGroup.name | lowercase}}_api" class="content-group-title">{{methodGroup.name}} API</a>
                
                <div class="content-item" 
                    data-ng-repeat="method in methodGroup.methods" 
                    data-ng-if="!method.deprecated"
                    data-ng-init="codeItem = codeContent[method.plainName]">
                    
                    <div id="{{method.plainName}}" section-title="{{method.plainName}}">
                        
                        <div class="item-title">
                            <a screen-link=":{{method.plainName}}" data-ng-bind-html="method.signature"></a>
                            <span class="title-label deprecated-label" data-ng-if="method.deprecated">deprecated</span>
                            <span class="title-label new-label" data-ng-if="method.new">new</span>
                        </div>
                        <div class="item-subtitle alternative" data-ng-if="method.extension">
                            <span>Requires Extension: &nbsp;</span>
                            <a screen-link="getit:{{method.extension}}">{{method.extension}}</a>
                        </div>
                        <p class="item-description" data-ng-bind-html="method.description"></p>
                        
                        <table class="api-table" data-ng-if="method.arguments || method.return">
                            <thead>
                                <tr>
                                    <th>
                                        <span data-ng-if="method.arguments.length > 0">Arguments</span>
                                        <span class="gray" data-ng-if="method.arguments.length === 0">No Arguments</span>
                                    </th>
                                    <th class="center">Type</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody data-ng-repeat="argument in method.arguments">
                                <tr>
                                    <td><code data-ng-bind-html="argument.name"></code></td>
                                    <td class="nowrap center" data-ng-bind-html="argument.types[0].type"></td>
                                    <td data-ng-bind-html="argument.types[0].description"></td>
                                </tr>
                                <tr data-ng-repeat="argType in argument.types.slice(1)">
                                    <td></td>
                                    <td class="nowrap center" data-ng-bind-html="argType.type"></td>
                                    <td data-ng-bind-html="argType.description"></td>
                                </tr>
                            </tbody>
                            <tbody>
                                <tr>
                                    <td class="return">Return</td>
                                    <td class="nowrap center" data-ng-bind-html="method.return[0].type"></td>
                                    <td data-ng-bind-html="method.return[0].description"></td>
                                </tr>
                                <tr data-ng-repeat="returnType in method.return.slice(1)">
                                    <td></td>
                                    <td class="nowrap center" data-ng-bind-html="returnType.type"></td>
                                    <td data-ng-bind-html="returnType.description"></td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <div data-ng-repeat="argumentDetail in method.argumentDetails" data-ng-if="method.argumentDetails">
                            <div class="item-subtitle">Argument: <code>{{argumentDetail.name}}</code></div>
                            <table class="api-table">
                                <thead>
                                    <tr>
                                        <th>Property</th>
                                        <th class="center">Type</th>
                                        <th class="center">Required</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody data-ng-repeat="property in argumentDetail.properties">
                                    <tr>
                                        <td data-ng-bind-html="property.name"></td>
                                        <td class="nowrap center" data-ng-bind-html="property.types[0].type"></td>
                                        <td class="center" data-ng-bind-html="property.types[0].required"></td>
                                        <td data-ng-bind-html="property.types[0].description"></td>
                                    </tr>
                                    <tr data-ng-repeat="propertyType in property.types.slice(1)">
                                        <td></td>
                                        <td class="nowrap center" data-ng-bind-html="propertyType.type"></td>
                                        <td class="center" data-ng-bind-html="propertyType.required"></td>
                                        <td data-ng-bind-html="propertyType.description"></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="data-table" data-ng-if="method.methodEnumeration">
                            <div class="item-subtitle">Method List</div>
                                
                            <div class="data-col" data-ng-repeat="colGroup in [col1TypeEnumerationGroups, col2TypeEnumerationGroups]">
                                <div data-ng-repeat="typeEnumGroup in colGroup">
                                    <div class="data-cell-title">{{method.methodEnumeration[typeEnumGroup].name}}</div>
                                    <div class="data-cell" data-ng-repeat="methodItem in method.methodEnumeration[typeEnumGroup].methods" data-ng-bind-html="methodItem"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="section-footnote" data-ng-bind-html="method.notes" data-ng-if="method.notes"></div>
                        
                        <div class="item-subtitle" data-ng-if="codeItem.codeSamples">Example</div>
                        
                        <code-snippet code-item="codeItem" default-view="compact"></code-snippet>                        
                    </div>
                </div>
                
            </div>
        </div>
                
        <div class="colspan-30 right-nav-container">
            <ul class="right-nav">
                <li data-ng-repeat="methodGroup in methodGroups" scroll-fixed>
                    <a screen-link=":{{methodGroup.name | lowercase}}_api">{{methodGroup.name | lowercase}}</a>
                </li>
                <li><a screen-link=":menu" class="circle-button up active"></a></li>
            </ul>
        </div>
        
    </div>
    
    <div ui-view></div> <!-- dummy child view -->
    
</section>
<content-wrapper code-artifact="api">


<content name="xtype">
xtype(-2.5)   === '{negative_float}';         //#:4:8 Value is number, negative and float
xtype('  ')   === '{whitespace}';             //#:4:8 Value is string and blank
xtype({})     === '{empty_object}';           //#:4:8 Value is object and is empty
xtype(['hi']) === '{single_elem_array}';      //#:4:8 Value is array, has exactly one element
</content>




<content name="type">
xtype.type(null)              === '{null}';
xtype.type(undefined)         === '{undefined}';
xtype.type(NaN)               === '{nan}';

xtype.type([])                === '{array}';
xtype.type({})                === '{object}';
xtype.type(new Date())        === '{date}';
xtype.type(function() {})     === '{function}';
xtype.type(/ab+c/i)           === '{regexp}';
xtype.type(new Error('No!')   === '{error}';
xtype.type(Symbol())          === '{symbol}';

xtype.type('Hi')              === '{string}';
xtype.type(new String('Hi'))  === '{string}';
xtype.type(25)                === '{number}';
xtype.type(new Number(25))    === '{number}';
xtype.type(true)              === '{boolean}';
xtype.type(new Boolean(true)) === '{boolean}';
</content>




<content name="typeOf">
function getArgumentsObject() {
    return arguments;
}

xtype.type(getArgumentsObject())    === '{object}';

// However:

xtype.typeOf(getArgumentsObject())  === 'arguments';
</content>




<content name="registerNameScheme">
var customNameScheme = {
    positive_number: 'pos_num', 
    empty_object: 'emp_obj', 
    blank_string: 'bl_str'
    /* More entries */
};

xtype.ext.registerNameScheme('my_custom_scheme', customNameScheme);

// The custom scheme is now internally registered
// and can now be referenced by name:

xtype.options.setNameScheme('my_custom_scheme');

xtype({})       === 'emp_obj';
xtype(25)       === 'pos_num';
xtype('  ')     === 'bl_str';

xtype.is({}, 'emp_obj')    === true;
xtype.is(25, 'pos_num')    === true;
xtype.is('  ', 'bl_str')   === true;
</content>




<content name="options_setNameScheme">
// Switch to the 'compact' name scheme:

xtype.options.setNameScheme('compact');

xtype({})             === 'obj0';    // 'obj0' is empty_object in new scheme
xtype(25)             === 'int+';    // 'int+' is positive_integer in new scheme
xtype.is({}, 'obj0')  === true;
xtype.is(25, 'int+')  === true;

// Any custom scheme which was already
// previously registered can also be used:

xtype.options.setNameScheme('my_custom_scheme');
</content>




<content name="options_set">
// Switch to the 'compact' name scheme:

xtype.options.set({
    delimiterPattern: '',
    nameScheme: 'compact'
});

// Or, if using a custom unnamed scheme:

xtype.options.set({
    delimiterPattern: '',
    nameScheme: {
        string: 'str',
        empty_string: 'emp_str',
        /* More name scheme entries */
    }
});
</content>




<content name="options_setDelimiterPattern">
xtype.options.setDelimiterPattern('/');

xtype.is(0, '{zero} / {positive_number}')     === true;
xtype.is(25, '{zero} / {positive_number}')    === true;
xtype.is(-3, '{zero} / {positive_number}')    === false;

// Using a different pattern to also allow the comma character:

xtype.options.setDelimiterPattern('[/,]');

xtype.is(25, '{zero}, {positive_number} / {float}') === true;
</content>




<content 
    name="noConflict"
    description="
    To reassign the xtype module to the 'otherName' variable, and return the 
    global 'xtype' variable to its previous value prior to importing xtypejs:">

var otherName = xtype.noConflict();

otherName.isPositiveInteger(5) === 'true';      // otherName is now xtypejs
</content>




<content 
    name="newInstance"
    skip-views="default"
    description="
    Create two different xtypejs module instances where one is setup to use the 
    default name scheme whereas the other is setup for the compact name scheme.">

// Obtain original xtypejs instance. Here we use nodejs-style
// require, but could be any other way of obtaining the module:

var xtype = require('xtypejs');

// Because the 'default' name scheme is the default for new xtypejs
// module instances, the following statement is not necessary for
// a newly created instance, but is included here for clarity:

xtype.options.setNameScheme('default');

// Create a new instance (named xtypeCompact in this case)
// of xtypejs and set it to use the 'compact' name scheme:

var compactNameScheme = require('xtypejs-name-scheme-compact');

var xtypeCompact = xtype.newInstance();
xtypeCompact.ext.registerNameScheme('compact', compactNameScheme);
xtypeCompact.options.setNameScheme('compact');

// Now the original instance (xtype) uses the default descriptive type
// names of the 'default' scheme, whereas the xtypeCompact instance
// uses the concise names of the 'compact' name scheme:

xtype(29.3)         === 'positive_float';
xtypeCompact(29.3)  === '{positive_float}';

// Each can be further configured and used independently of each other.
</content>




<content 
    name="which"
    description="
    Switch on the result of xtype.which() to handle only valid data scenarios without 
    first performing extensive type checking and data validations. For instance, in an 
    application or library that receives a varying piece of information with which a 
    product should be displayed, the following example handles three scenarios for the 
    type of product-related information received.">

switch (xtype.which(value, ['{multi_char_string}', '{positive_integer}', Product])) {

    case '{multi_char_string}':
        // Fetch and display product with value as the product name string

    case '{positive_integer}':
        // Fetch and display product with value as the product Id number

    case Product:
        // value is already a Product object, so just display it

    default:
        // Handle invalid value.. cannot display product
}
</content>




<content
    name="is"
    description ="
    Complex type and data requirements can be concisely validated using combinations 
    of relevant simple and/or extended types. The following example returns true only if - 
    data is an object and contains at least one own property, or is an array and has 
    exactly one element, or is a number and has an integer value and is greater than zero.">

xtype.is(value, '{single_elem_array}, {positive_integer}');

xtype.is(value, xtype.SINGLE_ELEM_ARRAY & xtype.POSITIVE_INTEGER);

// The following example returns true if the value is a multi-character
// string, a positive integer or a Product instance:

xtype.is(value, ['{multi_char_string}', '{positive_integer}', Product]);
</content>




<content name="not_isType">
xtype.not.isNull(null)                   === false;
xtype.not.isFalse(true)                  === true;
xtype.not.isNaN(12)                      === true;

xtype.not.isNegativeNumber(1.3)          === true;
xtype.not.isWhitespace('   ')            === false;
xtype.not.isZero(0.0)                    === false;

xtype.not.isEmptyArray(['hi'])           === true;
xtype.not.isSinglePropObject({ one: 1 }) === false;
xtype.not.isMultiPropObject({ one: 1 })  === true;
</content>




<content name="none_isType">
xtype.none.isNan(7, 2.5, NaN, 0, -5)                === false;
xtype.none.isBlankString('Tom', 0, true, null, ' ') === false;
xtype.none.isFloat(3, -5, 7)                        === true;
xtype.none.isFalse(true, true, false, true)         === false;
</content>




<content name="any_isType">
xtype.any.isNan(7, 2.5, NaN, 0, -5)                 === true;
xtype.any.isBlankString('Tom', 0, true, null, ' ')  === true;
xtype.any.isFloat(3, -5, 7)                         === false;
xtype.any.isFalse(true, true, false, true)          === true;
</content>




<content name="some_isType">
xtype.some.isFloat(7, 2.5, NaN, 0, -5)         === true;
xtype.some.isString('Tom', 0, true, null, ' ') === true;
xtype.some.isFloat(3, -5, 7)                   === false;
xtype.some.isInteger(3, -5, 7)                 === false; // All integer, not some
</content>




<content name="all_isType">
xtype.all.isFloat(7, 2.5, NaN, 0, -5)         === true;
xtype.all.isNonBlankString('hi', 'Tom', 'pi') === false;
xtype.all.isFloat(3.1, -5.5, 7)               === false;
xtype.all.isNonZeroNumber(3, -5, 7)           === true;
</content>




<content name="isType">
xtype.isSingleCharString('g')           === true;
xtype.isNonEmptyObject({foo: 'bar'})    === true;
xtype.isSingleElemArray(['foo'])        === true;

xtype.isFloat(2.50)                     === true;
xtype.isPositiveNumber(-2.5)            === false;
xtype.isNan(5 / 'hi')                   === true;
</content>




<content name="registerType">

/*
 * ---------------------------------------------------------------
 * REGISTER A DERIVED TYPE THAT MATCHES ALL OF THE COMPONENT TYPES
 * ---------------------------------------------------------------
 */

// To register a new type with name 'non_negative_integer', that validates
// when a data value matches both of the existing 'non_negative_number' and
// 'integer' types:

xtype.ext.registerType('non_negative_integer', {
    definition: 'non_negative_number, integer',
    matchMode: 'all'
});

xtype.isNonNegativeInteger(value);
xtype.is(value, 'non_negative_integer');


// To register a new type and also specify the corresponding names for the
// type in other name schemes, the 'schemeAliases' property can be used.
// For instance, to register the 'non_negative_integer' type also specifying
// '-int-' as the name of the type in the 'compact' name scheme:

xtype.ext.registerType('non_negative_integer', {
    definition: 'non_negative_number, integer',
    matchMode: 'all',
    schemeAliases: { compact: '-int-' }
});

xtype.isNonNegativeInteger(value);
xtype.is(value, '{@type:non_negative_integer:-int-}');


// The name of the new type can also be specified for several custom name
// schemes as part of the type registration. For instance, the following also
// specifies the type names for both the 'compact' and 'allcaps' name schemes:

xtype.ext.registerType('non_negative_integer', {
    definition: 'non_negative_number, integer',
    matchMode: 'all',
    schemeAliases: {
        compact: '-int-',
        allcaps: 'NON_NEGATIVE_INTEGER'
    }
});

/*
 * ---------------------------------------------------------------
 * REGISTER A DERIVED TYPE THAT MATCHES ANY OF THE COMPONENT TYPES
 * ---------------------------------------------------------------
 */

// To register a new type named 'flag' that validates when a data
// value is either a positive integer or a single character string:

xtype.ext.registerType('flag', {
    definition: 'positive_integer, single_char_string',
    // matchMode omitted because 'any' is the default
});

xtype.isFlag(value);
xtype.is(value, 'flag');


// But because only the 'definition' property is used in the 'flag'
// custom type registration above, it can be simplified to use the
// type expression string parameter format instead, which in this
// case accomplishes exactly the same thing:

xtype.ext.registerType('flag', 'positive_integer, single_char_string');


/*
 * ------------------------------
 * REGISTER A SELF-VALIDATED TYPE
 * ------------------------------
 */

// To register a type named 'social_security_number' that validates SSNs,
// and with 'ssn' as the name of the type in the 'compact' name scheme:

xtype.ext.registerType('social_security_number', {
    definition: {
        validator: function(val) {
            return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
        },
        schemeAliases: { compact: 'ssn' }
    }
});

xtype.isSocialSecurityNumber(value);
xtype.is(value, '{@type:social_security_number:ssn}');


// To register it simply with a single name 'ssn' as both the default name
// and name in any custom name schemes, then the registration can just be:

xtype.ext.registerType('ssn', {
    validator: function(val) {
        return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
    }
});

xtype.isSsn(value);
xtype.is(value, 'ssn');


/*
 * -------------------------
 * REGISTER AN INSTANCE TYPE
 * -------------------------
 */

// To register an instance type constructor function, Product,
// using the default name 'product' and with 'prod' as the name
// of the type in the 'compact' name scheme:

xtype.ext.registerType('product', {
    definition: Product,
    schemeAliases: { compact: 'prod' }
});

xtype.isProduct(value);
xtype.is(value, '{@type:product:prod}');


// To register it simply with a single name 'prod' as both the
// default name and name in any custom name schemes, then the
// simple function parameter format can be used:

xtype.ext.registerType('prod', Product);

xtype.isProd(value);
xtype.is(value, 'prod');


/*
 * -------------------------------
 * REGISTER MULTIPLE TYPES AT ONCE
 * -------------------------------
 */

xtype.ext.registerType({

    non_negative_integer: {                             // Derived type: match all
        definition: 'non_negative_number, integer',
        matchMode: 'all',
        schemeAliases: { compact: '-int-' }
    },
    
    social_security_number: {                           // Self-validated type
        definition: {
            validator: function(val) {
                return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
            },
            schemeAliases: { compact: 'ssn' }
        }
    },
    
    flag: 'positive_integer, single_char_string',       // Derived type: match any
    
    product: Product                                    // Instance type
});

</content>




<content name="idToName">
xtype.util.idToName(xtype.POSITIVE_INTEGER) === '{positive_integer}';
</content>




<content name="nameToId">
xtype.util.idToName('{positive_integer}') === xtype.POSITIVE_INTEGER;
</content>



</content-wrapper>


<section id="guide-screen-content" class="screen-content" template-artifact="guide">
    
    <div class="screen-content-links">
        <div class="cols-2">
            <div>
                <ul>
                    <li data-ng-repeat="contentName in col1Items">
                        <a screen-link=":{{contentName}}">{{guideContent[contentName].attributes.title}}</a>
                    </li>
                </ul>
            </div>
        </div>
        <div class="cols-2">
            <div>
                <ul>
                    <li data-ng-repeat="contentName in col2Items">
                        <a screen-link=":{{contentName}}">{{guideContent[contentName].attributes.title}}</a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="screen-content-body">        
        <div class="colspan-80">
            
            <div class="content-group">
                
                <div class="content-item" 
                    data-ng-repeat="contentName in AppUtils.keys(guideContent)" 
                    data-ng-init="codeItem = guideContent[contentName]">
                    
                    <div id="{{contentName}}" section-title="{{codeItem.attributes.title}}">
                        
                        <div class="item-title" data-ng-if="codeItem.attributes.title">
                            <a screen-link=":{{contentName}}">{{codeItem.attributes.title}}</a>
                        </div>
                        
                        <code-snippet code-item="codeItem" default-view="compact"></code-snippet>
                    </div>
                </div>
                
            </div>
        </div>
        
        <div class="colspan-20 right-nav-container">
            <ul class="right-nav">
                <li><a screen-link=":menu" class="circle-button up active"></a></li>
            </ul>
        </div>
        
    </div>
    
    <div ui-view></div> <!-- dummy child view -->
    
</section>
<content-wrapper code-artifact="guide">


<content 
    name="installing" 
    title="Installing" 
    lang="sh">

# npm:
npm install xtypejs --save

# npm from github:
npm install git://github.com/lucono/xtypejs.git

# bower:
bower install xtypejs --save

# bower from github:
bower install git://github.com/lucono/xtypejs.git
</content>




<content 
    name="importing_node_requirejs" 
    title="Importing with node and requireJS">

var xtype = require('xtypejs');             // node.js and CommonJS

require(['xtype'], function(xtype) {        // requirejs and AMD
    // Use xtype here
});
</content>




<content 
    name="importing_with_html_script_tag" 
    title="Importing with HTML script tag"
    lang="html">

<script src="path/to/xtype.js"></script>    <!-- exports xtype global variable -->
    
<script>
    // Use xtype here
</script>
</content>




<content 
    name="types_and_validation" 
    title="Pseudo types and data validation in xtypejs"
    description="
    xtypejs uses the concept of 'types' (or pseudo types) for data validation. 
    Each 'type' captures a set of validation criteria which must be satisfied 
    by a data value in order for it to be considered of that 'type'.
    <p>
    For instance, the pseudo type 'positive_integer' is defined to identify 
    data values which are a JavaScript 'number', are also whole number values, 
    and are positive, and is therefore used to validate a data value for 
    these criteria.    
    </p>
    <p>
    Any type in xtypejs can be described as being a Simple type, Extended type, 
    Instance type, Self-validated type, or Derived type, and a type can fall
    into more than one category.
    </p>
    <p>
    Simple types are the base set of types that include the fundamental 
    JavaScript data and built-in object types, in addition to the xtypejs 
    'nan' type. The simple types are: null, undefined, boolean, string, number, 
    nan, function, symbol, object, array, date, error, and regexp.    
    </p>
    <p>
    Extended types are the xtypejs built-in types, such as 'positive_integer', 
    which further specialize the simple types into types with data-validating qualities.   
    </p>
    <p>
    Instance types are types that validate values to be ojects of specific constructors.
    </p>
    <p>
    Self-validated types are types that define their own arbitrary custom validation for 
    validating any data value.
    </p>
    <p>
    Derived types are simply types created from combinations of multiple other types, 
    resulting in new validation criteria that are based on those of the component types.
    </p>">

</content>



<content 
    name="getting_extended_type" 
    title="Getting the extended type of a value">

xtype(-2.5)   === '{negative_float}';       // Value is number, negative and float
xtype('  ')   === '{whitespace}';           // Value is string and blank
xtype({})     === '{empty_object}';         // Value is object and is empty
xtype(['hi']) === '{single_elem_array}';    // Value is array, has exactly one element
</content>




<content 
    name="getting_simple_type" 
    title="Getting the simple type of a value">

xtype.type(null)              === '{null}';
xtype.type(undefined)         === '{undefined}';
xtype.type(NaN)               === '{nan}';

xtype.type([])                === '{array}';
xtype.type({})                === '{object}';
xtype.type(new Date())        === '{date}';
xtype.type(function() {})     === '{function}';
xtype.type(/ab+c/i)           === '{regexp}';
xtype.type(new Error('No!')   === '{error}';
xtype.type(Symbol())          === '{symbol}';

xtype.type('Hi')              === '{string}';
xtype.type(new String('Hi'))  === '{string}';
xtype.type(25)                === '{number}';
xtype.type(new Number(25))    === '{number}';
xtype.type(true)              === '{boolean}';
xtype.type(new Boolean(true)) === '{boolean}';
</content>




<content 
    name="checking_combinations_of_types" 
    title="Checking values against combinations of various types"
    description="
    Complex type and data requirements can be concisely validated using combinations of 
    relevant simple and/or extended types. The following example returns true only if - 
    data is an object and contains at least one own property, or is an array and has exactly 
    one element, or is a number and has an integer value and is greater than zero.">

xtype.is(data, '{{non_empty_object, single_elem_array, positive_integer}}');
</content>




<content 
    name="checking_instance_types" 
    title="Checking Instance types"
    description="
    Instance types are used to validate values to be ojects of a specific constructor.
    Any constructor function can be used as the Instance type for validating objects of that
    constructor. The following example returns true only if value is a Product object
    (where Product is a constructor function):">

xtype.is(value, Product);
</content>




<content 
    name="checking_instance_and_other_types" 
    title="Checking instance types along with other types"
    description="
    For instance, in an application or library method that receives a varying 
    piece of information with which a product should be displayed, the following 
    example validates that the value is either a product name string (multi character string), 
    a product Id number (positive integer), or an actual Product instance.">

xtype.is(value, ['{multi_char_string}', '{positive_integer}', Product]);

switch (xtype.which(value, ['{multi_char_string}', '{positive_integer}', Product])) {

    case '{multi_char_string}':
        // value is a multi-character string

    case '{positive_integer}':
        // value is a positive integer

    case Product:
        // value is a Product object
}
</content>




<content 
    name="instance_types_in_expression_strings" 
    title="Using instance types in type expression strings"
    description="
    Because an instance type is by default represented by the corresponding constructor 
    function for objects of that instance, instance types cannot be used in type expression 
    strings in the same convenient way that other types can. However, an instance type 
    can be registered with a specific name, making it possible to use it in type expression 
    strings just like other types. The following example shows the use of a Product instance 
    type, first with a constructor function, and then after type registration.">

// Product instance type referenced using the constructor function:

xtype.is(value, ['str2+', 'int+', Product]);

// However, registering the instance type gives it a type name:

xtype.ext.registerType('product', Product);

// The type name can then be used as the Instance type in type expressions:

xtype.is(value, '{{multi_char_string, positive_integer,}} product');

</content>




<content 
    name="checking_values_in_different_ways" 
    title="Checking values in different ways"
    description="Different ways of checking values provide flexibility based on application needs and constraints.">

// Verify if 'flag' variable is a single character string:

xtype.is(flag, '{single_char_string}');
xtype.is(flag, xtype.SINGLE_CHAR_STRING);
xtype.isSingleCharString(flag);


// Verify if 'flag' variable is a single character string or positive number value:

xtype.is(flag, '{{single_char_string, positive_number}}');
xtype.is(flag, xtype.SINGLE_CHAR_STRING | xtype.POSITIVE_NUMBER);
xtype.is(flag, ['{single_char_string}', xtype.POSITIVE_NUMBER]);
</content>




<content 
    name="validating_value_against_specific_type" 
    title="Validating a value against a specific type">

xtype.isSingleCharString('g')           === true;
xtype.isNonEmptyObject({foo: 'bar'})    === true;
xtype.isSingleElemArray(['foo'])        === true;

xtype.isFloat(2.50)                     === true;
xtype.isPositiveNumber(-2.5)            === false;
xtype.isNan(5 / 'hi')                   === true;
</content>




<content 
    name="validating_multiple_values_against_specific_type" 
    title="Validating multiple values against a specific type"
    description="The 'none', 'any', 'some', and 'all' method extensions provide the checking of multiple values against a single type.">

xtype.none.isNan(7, 2.5, NaN, 0, -5)        === false;
xtype.any.isZero(7, 2.5, NaN, 0, -5)        === true;
xtype.all.isPositiveInteger(3, 5.1, 7)      === false;

xtype.some.isFloat(3, 5.5, 7)               === true;       // Some but not all are float
xtype.some.isFloat(2.5, 8.5, 2.1)           === false;      // All are float, not some
xtype.all.isNonZeroNumber(4, -20, 8.5)      === true;


// They can also take a single array of the values to be checked:

var values = ['Tom', 0, true, null, ' '];

xtype.any.isNothing(values)        === true;     // null is of 'nothing' type
xtype.all.isPrimitive(values)      === false;    // null is of 'nothing' type, not 'primitive'
xtype.none.isBlankString(values)   === false;
xtype.some.isTrue(values)          === true;
</content>




<content
    name="switching_based_on_value_type"
    title="Switching based on the type of a value"
    description="
    Switch on the result of xtype.which() to handle only valid data scenarios without 
    first performing extensive type checking and data validations. For instance, in an 
    application or library that receives a varying piece of information with which a 
    product should be displayed, the following example handles three scenarios for the 
    type of product-related information received.">

switch (xtype.which(value, '{{multi_char_string, positive_integer, nothing}}')) {

    case '{multi_char_string}':
        // Fetch and display product with value as the product name string

    case '{positive_integer}':
        // Fetch and display product with value as the product Id number

    case '{nothing}':
        // value is null or undefined, handle no value provided

    default:
        // value is present but not any of expected 'types', do error
}
</content>




<content 
    name="checking_boolean_values" 
    title="Checking boolean values">

xtype.isTrue(23.5)                  === false;      // Truthy but not boolean
xtype.isTrue(new MyProduct())       === false;      // Any type can be checked
xtype.isTrue('true')                === false;      // String is not boolean
xtype.isFalse('false')              === false;      // String is not boolean

xtype.isTrue(true)                  === true;       // Primitive true is actual true
xtype.isTrue(new Boolean(true))     === true;       // Object true is actual true

xtype.isFalse(false)                === true;       // Primitive false is actual false
xtype.isFalse(new Boolean(false))   === true;       // Object false is actual false
</content>




<content 
    name="application_flag_example" 
    title="Single character application flag example"
    description="
    Suppose a single character application/operation flag is expected as input. 
    The 'single_char_string' extended type will match a string that contains 
    exactly one non-whitespace character, regardless of whether it also contains 
    other whitespace characters.">

xtype.isSingleCharString('t')               === true;
xtype.isSingleCharString(' g ')             === true;
xtype.isSingleCharString('  ')              === false;
xtype.isSingleCharString('q1')              === false;
xtype.isSingleCharString(new String(' z ')) === true;
</content>




<content
    name="normalized_type_checking"
    title="Normalized type checking"
    description="Primitive types and their corresponding object types share the same simple types.">
 
// Regular type checking:

typeof 'foo'                === 'string';
typeof new String('foo')    === 'object';


// Type checking with xtypejs:

xtype.type('foo')               === '{string}';
xtype.type(new String('foo'))   === '{string}';

xtype.type(25)                  === '{number}';
xtype.type(new Number(25))      === '{number}';

xtype.isZero(0)                 === true;
xtype.isZero(new Number(0))     === true;
</content>




<content
    name="creating_derived_types"
    title="Creating new types derived from combinations of existing types"
    description="
    Any number of new types can be derived from combinations of several 
    existing types, and then used like, and/or together with, all other 
    existing types.">

/*
 * -------------------------------------------------------------
 * CREATING DERIVED TYPE THAT MATCHES ALL OF THE COMPONENT TYPES
 * -------------------------------------------------------------
 */

// To create a new type named 'non_negative_integer', that validates
// when a data value matches both of the existing 'non_negative_number'
// and 'integer' types:


xtype.ext.registerType('non_negative_integer', {
    definition: 'non_negative_number, integer',
    matchMode: 'all'
});


// The type expression value of the 'definition' property may include any
// existing types, including built-in types, registered instance types and
// other already registered custom and derived types. However, it must use the
// default type names of the component types and not those of any name scheme that
// was registered in xtypejs, such as for example, the 'compact' name scheme.


/*
 * -------------------------------------------------------------
 * CREATING DERIVED TYPE THAT MATCHES ANY OF THE COMPONENT TYPES
 * -------------------------------------------------------------
 */

// The value of the 'matchMode' property can be 'all' to match all the
// component types, or 'any' (the default when omitted) to match any
// of the component types. For instance, to register a new type named
// 'app_flag' that validates when a data value is either a positive integer
// or a single character string:


xtype.ext.registerType('app_flag', {
    definition: 'positive_integer, single_char_string',
    matchMode: 'any'
});


// However, because 'any' is the default value for matchMode,
// for creating our 'app_flag' type we can just have:


xtype.ext.registerType('app_flag', {
    definition: 'positive_integer, single_char_string'
});


// But again, because only the 'definition' attribute is used in the 
// type registration, we can simply have:


xtype.ext.registerType('app_flag', 'positive_integer, single_char_string');


/*
 * ----------------------------------------------------------------
 * PROVIDING TYPE NAMES FOR THE CUSTOM TYPE IN VARIOUS NAME SCHEMES
 * ----------------------------------------------------------------
 */

// Using the 'schemeAliases' key, we can provide the names to be used 
// for the newly registered type for various custom name schemes that 
// are registered with xtypejs:

xtype.ext.registerType('app_flag', {
    definition: 'positive_integer, single_char_string',
    schemeAliases: {
        compact: 'flag'
    }
});

/*
 * ---------------------------------
 * USE NEWLY REGISTERED DERIVED TYPE
 * ---------------------------------
 */

// After registration of the new types, we can now use them in type checking:


xtype.is(value, '{@type:non_negative_integer:-int-}');
xtype.is(value, '{@type:app_flag:flag}');


// New 'is' methods with the camel-cased name of the new types will
// also become available on the xtype module for checking the types:

 
xtype.isNonNegativeInteger(value);
xtype.isAppFlag(value);

</content>




<content
    name="creating_self_validated_types"
    title="Creating self-validated types having arbitrary custom validation"
    description="
    Self-validated types having any arbitrary custom validation can be created by
    registering them and providing an object in the 'definition' field which should 
    have a 'validator' property whose value is the validator function for the 
    custom type. The validator function must be able to accept as the first argument, 
    the value being validated, and return true (not a truthy value) if the value is 
    considered valid for the type.">

// To create a type named 'social_security_number' for validating SSNs:

xtype.ext.registerType('social_security_number', {
    definition: {
        validator: function(val) {
            return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
        },
        schemeAliases: {
            compact: 'ssn'
        }
    }
});


// After registration of the new type, we can now use it in type checking:

xtype.is(value, '{@type:social_security_number:ssn}');
xtype.isSocialSecurityNumber(value);


// However, if we just wanted to register it simply with a single name 'ssn' as 
// both the default and compact names, then the registration could just be:

xtype.ext.registerType('ssn', {
    validator: function(val) {
        return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
    }
});

xtype.is(value, 'ssn');
xtype.isSsn(value);

</content>




<content
    name="registering_instance_types_internally"
    title="Registering Instance types internally"
    description="
    Any constructor function can be used directly as the Instance type identifier 
    for validating objects of that constructor, even without having been registered 
    with xtypejs. However, when an instance type is registered with xtypejs, a
    validation method dedicated to that instance type becomes available on the
    xtype module, and the instance type is also then able to be referenced in type 
    expression strings, much like all other types.">

// To register an instance type constructor function, Product,
// using the default name 'product' and the name 'prod' for 
// the 'compact' name scheme:

xtype.ext.registerType('product', {
    definition: Product,
    schemeAliases: {
        compact: 'prod'
    }
});


// After registration of the instance type, we can then use it in type 
// checking and in type expressions, like with most other types:

xtype.isProduct(value);
xtype.is(value, '{@type:product:prod}');
xtype.is(value, '{{multi_char_string, positive_integer,}} {@type:product:prod}');

</content>




<content
    name="delimiting_types_in_expressions"
    title="Delimiting types in type expression strings"
    description="
    By default, a comma or space or pipe character can be used as a delimiter in type 
    expression strings. Additional spaces can be used around delimiters, and are ignored.">

xtype.is(value, '{single_char_string},{positive_number}');
xtype.is(value, '{single_char_string}, {positive_number}');
xtype.is(value, '{single_char_string}|{positive_number}');
xtype.is(value, '{single_char_string} | {positive_number}');
xtype.is(value, '{single_char_string} {positive_number}'); 
</content>




<content
    name="using_custom_delimiter"
    title="Using a custom delimiter"
    description="
    A custom pattern can be used in place of the default type delimiters. This can be useful in 
    applications for which the default delimiters may not be ideal. For instance, if the type 
    expressions are being stored as part of data validation metadata, but the default delimiter 
    characters are problematic for the specific storage format being used. When a custom type
    delimiter pattern is used, it should be ensured that the characters allowed by the pattern 
    do not conflict with the characters in the type names of any type name schemes being used.">

xtype.options.setDelimiterPattern('/');

xtype.is(0, '{zero} / {positive_number}')     === true;
xtype.is(25, '{zero} / {positive_number}')    === true;
xtype.is(-3, '{zero} / {positive_number}')    === false;


// Using a different pattern to also allow the comma character:

xtype.options.setDelimiterPattern('[/,]');

xtype.is(25, '{zero}, {positive_number} / {float}') === true;
</content>




<content
    name="using_custom_name_scheme"
    title="Using name schemes"
    description="
    A name scheme provides the set of names or aliases used to refer to the various xtypejs 
    built-in and custom types. By default, there is the descriptive 'default' name scheme. 
    But there is also the flexibility to create and use custom name schemes according to user 
    preference and application needs. Also, a number of useful custom name schemes are officially 
    provided as separate modules and can easily be applied to xtypejs. See the 'Get It' tab for 
    a list of the officially provided name scheme modules.">
 
xtype.options.setNameScheme({
    positive_number: 'pos_num', 
    empty_object: 'emp_obj', 
    blank_string: 'bl_str'
    /* More entries */
});

xtype({})       === 'emp_obj';          // empty_object is 'emp_obj' in new scheme
xtype(25)       === 'pos_num';          // positive_integer is 'pos_num' in new scheme
xtype('  ')     === 'bl_str';           // blank_string is 'bl_str' in new scheme

xtype.is({}, 'emp_obj')    === true;
xtype.is(25, 'pos_num')    === true;
xtype.is('  ', 'bl_str')   === true;
</content>




<content
    name="switching_to_compact_name_scheme"
    title="Switching to the compact name scheme"
    description="
    <b>Important:</b> The 'compact' name scheme is provided by the 
    'xtypejs-name-scheme-compact' name scheme module, which needs to be applied 
    in xtypejs to make the 'compact' name sceheme available. See the 'Get It' tab 
    for details on this and other available name scheme and extension modules.">

// With the regular 'default' name scheme:

xtype({})                           === 'empty_object';
xtype(25)                           === 'positive_integer';
xtype.is({}, 'empty_object')        === true;
xtype.is(25, 'positive_integer')    === true;


// Switch to the 'compact' name scheme:

var compactNameScheme = require('xtypejs-name-scheme-compact');

xtype.ext.registerNameScheme('compact', compactNameScheme);
xtype.options.setNameScheme('compact');

xtype({})               === 'obj0';     // Compact scheme uses 'obj0' for 'empty_object'
xtype(25)               === 'int+';     // Compact scheme uses 'int+' for 'positive_integer'
xtype.is({}, 'obj0')    === true;
xtype.is(25, 'int+')    === true;
</content>




<content
    name="registering_custom_name_scheme"
    title="Registering a custom name scheme">

var customNameScheme = {
    positive_number: 'pos_num', 
    empty_object: 'emp_obj', 
    blank_string: 'bl_str'
    /* More entries */
};

xtype.ext.registerNameScheme('my_custom_scheme', customNameScheme);


// The custom scheme is now internally registered
// and can now be referenced by name:

xtype.options.setNameScheme('my_custom_scheme');

xtype({})       === 'emp_obj';
xtype(25)       === 'pos_num';
xtype('  ')     === 'bl_str';

xtype.is({}, 'emp_obj')    === true;
xtype.is(25, 'pos_num')    === true;
xtype.is('  ', 'bl_str')   === true;
</content>




<content
    name="switching_back_to_default_name_scheme"
    title="Switching back to the default name scheme">

xtype.options.setNameScheme('default');
</content>




<content 
    name="using_none_and_any_types" 
    title="Using the none and any types"
    description="
    The 'none' type represents the set of no types, which means that no value can actually 
    ever match 'none'. Therefore, xtype.isNone(value) will always be false for any value. 
    The 'any' type is the composite type consisting of all types, which means that all values 
    will always match 'any'. Therefore, xtype.isAny(value) will always be true for any value.">

// The 'none' type

xtype.isNone(25)                    === false;
xtype.isNone(['hi', 5])             === false;
xtype.isNone(undefined)             === false;

xtype.not.isNone('hello')           === true;         // true for any value
xtype.all.isNone('hi', 5, true)     === false;        // false for any list of values
xtype.some.isNone(null, 25, false)  === false;        // false for any list of values
xtype.any.isNone(null, 25, false)   === false;        // false for any list of values
xtype.none.isNone(null, 25, false)  === true;         // true for any list of values


// The 'any' type

xtype.isAny(25)                    === true;
xtype.isAny(['hi', 5])             === true;
xtype.isAny(undefined)             === true;

xtype.not.isAny('hello')           === false;         // false for any value
xtype.all.isAny('hi', 5, true)     === true;          // true for any list of values
xtype.some.isAny(null, 25, false)  === false;         // false for any list of values
xtype.any.isAny(null, 25, false)   === true;          // true for any list of values
xtype.none.isAny(null, 25, false)  === false;         // false for any list of values


// The 'any' type can be temporarily added to a validating type expression as a 
// switch to temporarily make it fully permissive, therefore accepting all values:

xtype.is(25, '{object}')           === false;
xtype.is(25, '{{object, any}}')    === true;          // allows any value to pass validation
</content>




<content 
    name="using_the_nan_type" 
    title="Using the nan type"
    description="
    The xtypejs 'nan' type is a representation of any invalid numeric value in JavaScript, 
    in a way that is completely decoupled and distinct from the JavaScript 'number' type. 
    This effectively eliminates the need for applications to explicitly check and handle 
    NaN values in the number context. This is beneficial as NaN values are problematic in 
    JavaScript applications, because though they are reported as the 'number' type by the 
    JavaScript runtime, there is effectively little to nothing an application can do to 
    make meaningful use of them in the number context.">

var validNumber = 5;                              // Valid number value
var nanValue = (5 / 'a');                         // NaN from invalid numeric computation
var boxedNanValue = new Number(nanValue);         // Boxed Number object having NaN value


/*
 * -------------------
 * Vanilla JavaScript:
 * -------------------
 */

typeof validNumber            === 'number';
typeof nanValue               === 'number';      // NaN is also of 'number' type
Number.isNaN(boxedNanValue)   === false;         // Boxed NaN Number not identified as NaN


/*
 * --------
 * xtypejs:
 * --------
 */
 
xtype.type(validNumber)       === 'number';
xtype.type(nanValue)          === 'nan';         // NaN is not 'number' type
xtype.isNan(boxedNanValue)    === true;          // Boxed NaN Number also identified as 'nan'
</content>




<content 
    name="prevent_name_collisions" 
    title="Preventing name collisions"
    description="
    When imported as a script tag, the xtype module is assigned to the global variable 'xtype'. 
    The 'noConflict' method can be used to reassign the xtype module to a different namespace or variable 
    name, and return the global 'xtype' variable to its previous value prior to importing xtypejs.">

var otherName = xtype.noConflict();

otherName.isPositiveInteger(5) === 'true';      // otherName is now xtypejs
</content>




<content 
    name="reporting_bugs_and_issues" 
    title="Reporting bugs and issues"
    description="
    Please report bugs or problems by creating an issue on the GitHub project 
    <a href='https://github.com/lucono/xtypejs/issues' target='_blank'>Issues Page</a>.">
</content>



</content-wrapper><section id="playground-screen-content" class="screen-content" template-artifact="playground">
    
    <div class="screen-content-links">

        <h1>Setup</h1>

        <div class="cols-2">
            <div>
                <ul>
                    <li data-ng-repeat="contentName in col1Items">
                        <a screen-link=":{{contentName}}">{{playgroundContent[contentName].attributes.title}}</a>
                    </li>
                </ul>
            </div>
        </div>
        <div class="cols-2">
            <div>
                <ul>
                    <li data-ng-repeat="contentName in col2Items">
                        <a screen-link=":{{contentName}}">{{playgroundContent[contentName].attributes.title}}</a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="screen-content-body">
        <div class="colspan-70">
        
            <div class="content-group">
            
                <div class="content-item">

                    <div id="{{contentName}}" style="height: 0px;" data-ng-repeat="contentName in contentNames"></div>

                    <div id="playground_editor">
                        
                        <div class="item-title">
                            <a screen-link=":playground_editor">Code Playground</a>
                        </div>
                        
                        <!--
                        <p class="item-description">
                            Play with xtypejs by typing and running code in the editor below. 
                            You can require xtypejs, any of the official xtypejs extensions and name schemes, 
                            and any other module in the npm repository.
                        </p>
                        -->
                        
                        <div id="playground_editor_box"></div>
                        
                    </div>
                </div>
                
            </div>
        </div>
        
        <div class="colspan-30 right-nav-container">
            <ul class="right-nav">
                <li><a screen-link=":menu" class="circle-button up active"></a></li>
            </ul>
        </div>
        
    </div>
    
    <div ui-view></div> <!-- dummy child view -->
    
</section><content-wrapper code-artifact="playground">



<content 
    name="basic_xtypejs" 
    title="Basic setup with just xtypejs">
    
var xtype = require('xtypejs');

</content>



<content 
    name="compact_name_scheme" 
    title="Compact name scheme">
    
var xtype = require('xtypejs');
var compactScheme = require('xtypejs-name-scheme-compact');

xtype.ext.registerNameScheme('compact', compactScheme);
xtype.options.setNameScheme('compact');

</content>



<content 
    name="custom_types" 
    title="Custom types">
    
var xtype = require('xtypejs');
var customTypes = require('xtypejs-extension-custom-types');

xtype.ext.registerExtension(customTypes);

</content>



<content 
    name="custom_types_compact_name_scheme" 
    title="Custom types and compact name scheme">
    
var xtype = require('xtypejs');
var customTypes = require('xtypejs-extension-custom-types');
var compactScheme = require('xtypejs-name-scheme-compact');

xtype.ext.registerExtension(customTypes);
xtype.ext.registerNameScheme('compact', compactScheme);
xtype.options.setNameScheme('compact');

</content>



<content 
    name="official_name_schemes" 
    title="Official name schemes">
    
var xtype = require('xtypejs');
var compactScheme = require('xtypejs-name-scheme-compact');
var shortScheme = require('xtypejs-name-scheme-shortened');
var camelScheme = require('xtypejs-name-scheme-camel');
var shortCamelScheme = require('xtypejs-name-scheme-shortened-camel');

xtype.ext.registerNameScheme('compact', compactScheme);
xtype.ext.registerNameScheme('shortened', shortScheme);
xtype.ext.registerNameScheme('camel', camelScheme);
xtype.ext.registerNameScheme('shortenedCamel', shortCamelScheme);

// You can now switch to any of the above registered name schemes. Eg:
// xtype.options.setNameScheme('compact');

</content>



<content 
    name="official_name_schemes_and_extensions" 
    title="Official name schemes and extensions">
    
var xtype = require('xtypejs');

var customTypes = require('xtypejs-extension-custom-types');
var typeNameUtils = require('xtypejs-extension-typename-utils');
var autoCamel = require('xtypejs-extension-autocamel-name-scheme');

xtype.ext.registerExtension(customTypes, typeNameUtils, autoCamel);

var compactScheme = require('xtypejs-name-scheme-compact');
var shortScheme = require('xtypejs-name-scheme-shortened');
var camelScheme = require('xtypejs-name-scheme-camel');
var shortCamelScheme = require('xtypejs-name-scheme-shortened-camel');

xtype.ext.registerNameScheme('compact', compactScheme);
xtype.ext.registerNameScheme('shortened', shortScheme);
xtype.ext.registerNameScheme('camel', camelScheme);
xtype.ext.registerNameScheme('shortenedCamel', shortCamelScheme);

</content>



</content-wrapper><section id="getit-screen-content" class="screen-content" template-artifact="getit">
    
    <div class="screen-content-links">        
        <div class="links-section-buttons">
            <a href="https://github.com/lucono/xtypejs/stargazers" target="_blank">
                <i class="fa fa-github fa-5x"></i>
                <!-- Star GitHub Project -->
            </a>
        </div>
        <div class="release-details">
            <h1>Current version {{latestVersion ? '- ' + latestVersion: ''}}</h1>
            <div data-ng-if="releaseDescription">
                <span data-ng-if="releaseTitle">{{releaseTitle}} &nbsp;&ndash;&nbsp; </span>
                {{releaseDescription}}
            </div>
        </div>
        <ul class="horizontal-links">
            <li data-ng-repeat="contentName in AppUtils.keys(getItContent)" data-ng-init="contentItem = getItContent[contentName]">
                <a screen-link=":{{contentName}}">{{contentItem.attributes.title}}</a>
            </li>
            <li>
                <a screen-link=":download">Download</a>
            </li>
            <li>
                <a screen-link=":extensions">Extensions</a>
            </li>
            <li>
                <a screen-link=":name_schemes">Name Schemes</a>
            </li>
        </ul>
    </div>
    
    <div class="screen-content-body">        
        <div class="colspan-70">
        
            <div class="content-group">
            
                <div class="content-item" 
                    data-ng-repeat="contentName in AppUtils.keys(getItContent)" 
                    data-ng-init="contentItem = getItContent[contentName]">
                    
                    <div id="{{contentName}}" section-title="{{contentItem.attributes.title}}">
                        
                        <div class="item-title" data-ng-if="contentItem.attributes.title">
                            <a screen-link=":{{contentName}}">{{contentItem.attributes.title}}</a>
                        </div>
                        
                        <p class="item-description" data-ng-if="contentItem.attributes.description">
                            {{contentItem.attributes.description}}
                        </p>
                        
                        <code-snippet code-item="contentItem"></code-snippet>
                        
                    </div>
                </div>
            
                <div class="content-item">
                    <div id="download" section-title="Download">
                        
                        <div class="item-title">
                            <a screen-link=":download">
                                Download
                                <!-- <span class="release-title" data-ng-if="releaseTitle"> &nbsp; &ndash; &nbsp; {{releaseTitle}}</span> -->
                            </a>
                        </div>
                        
                        <!-- <p class="item-description" data-ng-if="releaseDescription">{{releaseDescription}}</p> -->
                        <p class="item-description">The following downloads are available for this release:</p>
                        
                        <ul class="release-assets">
                            <li data-ng-repeat="asset in assets">
                                <a href="{{asset.browser_download_url}}">
                                    <i class="fa fa-2x fa-cloud-download"></i>
                                    <div>
                                        {{asset.name}}
                                    </div>
                                </a>
                            </li>
                            <li data-ng-if="!assets">
                                <a href="{{fallbackDownloadUrl}}" target="_blank"><i class="fa fa-2x fa-folder-open-o"></i> &nbsp; latest release</a>
                            </li>
                        </ul>
                    </div>
                </div>
            
                <div class="content-item">
                    <div id="extensions" section-title="Extensions">
                        
                        <div class="item-title">
                            <a screen-link=":extensions">
                                Extensions
                            </a>
                        </div>
                        
                        <p class="item-description">The official extensions below are provided as separate modules.</p>
                        
                        <ul class="release-assets">
                            <li data-ng-repeat="extension in extensions">
                                <a id="{{extension.name}}" href="{{extension.url}}" target="_blank">
                                    <i class="fa fa-2x fa-cube"></i>
                                    <div>
                                        {{extension.name}}
                                        <div class="asset-description">{{extension.description}}</div>
                                    </div>
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>
            
                <div class="content-item">
                    <div id="name_schemes" section-title="Name Schemes">
                        
                        <div class="item-title">
                            <a screen-link=":name_schemes">
                                Name Schemes
                            </a>
                        </div>
                        
                        <p class="item-description">The official name schemes below are provided as separate modules.
                            To learn more about name schemes, see <a screen-link="guide:using_custom_name_scheme">using name schemes</a>.
                        </p>
                        
                        <ul class="release-assets">
                            <li data-ng-repeat="nameScheme in nameSchemes">
                                <a href="{{nameScheme.url}}" target="_blank">
                                    <i class="fa fa-2x fa-hashtag"></i>
                                    <div>
                                        {{nameScheme.name}}
                                        <div class="asset-description">{{nameScheme.description}}</div>
                                    </div>
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>
                
            </div>
        </div>
        
        <div class="colspan-30 right-nav-container">
            <ul class="right-nav">
                <li><a screen-link=":menu" class="circle-button up active"></a></li>
            </ul>
        </div>
        
    </div>
    
    <div ui-view></div> <!-- dummy child view -->
    
</section>
<content-wrapper code-artifact="getit">


<content 
    name="npm" 
    title="Install with npm" 
    lang="sh">

npm install xtypejs --save
</content>


</content-wrapper>
<div template-artifact="codeSnippet"
    class="code-container {{activeView}}" 
    data-ng-if="(views.length > 0) || codeItem.attributes.description">
    
    <div class="code-content-window {{!codeItem.attributes.description ? 'no-description' : ''}}">
        <div class="code-content-description" 
            data-ng-bind-html="codeItem.attributes.description" 
            data-ng-if="codeItem.attributes.description">
        </div>
        <ul class="code-tabs" data-ng-if="(!noInfoLabel && (infoLabel || hasCompact)) || views.length > 1">
            <li class="tab-label" data-ng-if="!noInfoLabel && infoLabel" data-ng-bind-html="infoLabel"></li>
            <li class="tab-label" data-ng-if="!noInfoLabel && !infoLabel && hasCompact">Tip: <a screen-link="guide:switching_to_compact_name_scheme">Using compact names</a></li>
            <li class="{{view}}-view"
                data-ng-repeat="view in views" 
                data-ng-if="views.length > 1">
                <a href="" data-ng-click="switchView(view)">{{viewLabels[view]}}</a>
            </li>
        </ul>
        <div class="code-content" data-ng-if="codeItem.codeSamples">
            <div class="code-content-scroller">
                <pre data-ng-repeat="view in views" 
                    data-ng-bind-html="codeItem.codeSamples[view]"
                    class="{{view}}-view prettyprint">
                </pre>
            </div>
        </div>
    </div>
</div>

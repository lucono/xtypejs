
<content-wrapper code-artifact="api">


<content name="xtype">
xtype(-2.5)   === '{negative_float}';         //#:4:8 Value is number, negative and float
xtype('  ')   === '{whitespace}';             //#:4:8 Value is string and blank
xtype({})     === '{empty_object}';           //#:4:8 Value is object and is empty
xtype(['hi']) === '{single_elem_array}';      //#:4:8 Value is array, has exactly one element
</content>




<content name="type">
xtype.type(null)              === '{null}';
xtype.type(undefined)         === '{undefined}';
xtype.type(NaN)               === '{nan}';

xtype.type([])                === '{array}';
xtype.type({})                === '{object}';
xtype.type(new Date())        === '{date}';
xtype.type(function() {})     === '{function}';
xtype.type(/ab+c/i)           === '{regexp}';
xtype.type(new Error('No!')   === '{error}';
xtype.type(Symbol())          === '{symbol}';

xtype.type('Hi')              === '{string}';
xtype.type(new String('Hi'))  === '{string}';
xtype.type(25)                === '{number}';
xtype.type(new Number(25))    === '{number}';
xtype.type(true)              === '{boolean}';
xtype.type(new Boolean(true)) === '{boolean}';
</content>




<content name="typeOf">
function getArgumentsObject() {
    return arguments;
}

xtype.type(getArgumentsObject())    === '{object}';

// However:

xtype.typeOf(getArgumentsObject())  === 'arguments';
</content>




<content name="registerNameScheme">
var customNameScheme = {
    positive_number: 'pos_num', 
    empty_object: 'emp_obj', 
    blank_string: 'bl_str'
    /* More entries */
};

xtype.ext.registerNameScheme('my_custom_scheme', customNameScheme);

// The custom scheme is now internally registered
// and can now be referenced by name:

xtype.options.setNameScheme('my_custom_scheme');

xtype({})       === 'emp_obj';
xtype(25)       === 'pos_num';
xtype('  ')     === 'bl_str';

xtype.is({}, 'emp_obj')    === true;
xtype.is(25, 'pos_num')    === true;
xtype.is('  ', 'bl_str')   === true;
</content>




<content name="options_setNameScheme">
// Switch to the 'compact' name scheme:

xtype.options.setNameScheme('compact');

xtype({})             === 'obj0';    // 'obj0' is empty_object in new scheme
xtype(25)             === 'int+';    // 'int+' is positive_integer in new scheme
xtype.is({}, 'obj0')  === true;
xtype.is(25, 'int+')  === true;

// Any custom scheme which was already
// previously registered can also be used:

xtype.options.setNameScheme('my_custom_scheme');
</content>




<content name="options_set">
// Switch to the 'compact' name scheme:

xtype.options.set({
    delimiterPattern: '',
    nameScheme: 'compact'
});

// Or, if using a custom unnamed scheme:

xtype.options.set({
    delimiterPattern: '',
    nameScheme: {
        string: 'str',
        empty_string: 'emp_str',
        /* More name scheme entries */
    }
});
</content>




<content name="options_setDelimiterPattern">
xtype.options.setDelimiterPattern('/');

xtype.is(0, '{zero} / {positive_number}')     === true;
xtype.is(25, '{zero} / {positive_number}')    === true;
xtype.is(-3, '{zero} / {positive_number}')    === false;

// Using a different pattern to also allow the comma character:

xtype.options.setDelimiterPattern('[/,]');

xtype.is(25, '{zero}, {positive_number} / {float}') === true;
</content>




<content 
    name="noConflict"
    description="
    To reassign the xtype module to the 'otherName' variable, and return the 
    global 'xtype' variable to its previous value prior to importing xtypejs:">

var otherName = xtype.noConflict();

otherName.isPositiveInteger(5) === 'true';      // otherName is now xtypejs
</content>




<content 
    name="newInstance"
    skip-views="default"
    description="
    Create two different xtypejs module instances where one is setup to use the 
    default name scheme whereas the other is setup for the compact name scheme.">

// Obtain original xtypejs instance. Here we use nodejs-style
// require, but could be any other way of obtaining the module:

var xtype = require('xtypejs');

// Because the 'default' name scheme is the default for new xtypejs
// module instances, the following statement is not necessary for
// a newly created instance, but is included here for clarity:

xtype.options.setNameScheme('default');

// Create a new instance (named xtypeCompact in this case)
// of xtypejs and set it to use the 'compact' name scheme:

var compactNameScheme = require('xtypejs-name-scheme-compact');

var xtypeCompact = xtype.newInstance();
xtypeCompact.ext.registerNameScheme('compact', compactNameScheme);
xtypeCompact.options.setNameScheme('compact');

// Now the original instance (xtype) uses the default descriptive type
// names of the 'default' scheme, whereas the xtypeCompact instance
// uses the concise names of the 'compact' name scheme:

xtype(29.3)         === 'positive_float';
xtypeCompact(29.3)  === '{positive_float}';

// Each can be further configured and used independently of each other.
</content>




<content 
    name="which"
    description="
    Switch on the result of xtype.which() to handle only valid data scenarios without 
    first performing extensive type checking and data validations. For instance, in an 
    application or library that receives a varying piece of information with which a 
    product should be displayed, the following example handles three scenarios for the 
    type of product-related information received.">

switch (xtype.which(value, ['{multi_char_string}', '{positive_integer}', Product])) {

    case '{multi_char_string}':
        // Fetch and display product with value as the product name string

    case '{positive_integer}':
        // Fetch and display product with value as the product Id number

    case Product:
        // value is already a Product object, so just display it

    default:
        // Handle invalid value.. cannot display product
}
</content>




<content
    name="is"
    description ="
    Complex type and data requirements can be concisely validated using combinations 
    of relevant simple and/or extended types. The following example returns true only if - 
    data is an object and contains at least one own property, or is an array and has 
    exactly one element, or is a number and has an integer value and is greater than zero.">

xtype.is(value, '{single_elem_array}, {positive_integer}');

xtype.is(value, xtype.SINGLE_ELEM_ARRAY & xtype.POSITIVE_INTEGER);

// The following example returns true if the value is a multi-character
// string, a positive integer or a Product instance:

xtype.is(value, ['{multi_char_string}', '{positive_integer}', Product]);
</content>




<content name="not_isType">
xtype.not.isNull(null)                   === false;
xtype.not.isFalse(true)                  === true;
xtype.not.isNaN(12)                      === true;

xtype.not.isNegativeNumber(1.3)          === true;
xtype.not.isWhitespace('   ')            === false;
xtype.not.isZero(0.0)                    === false;

xtype.not.isEmptyArray(['hi'])           === true;
xtype.not.isSinglePropObject({ one: 1 }) === false;
xtype.not.isMultiPropObject({ one: 1 })  === true;
</content>




<content name="none_isType">
xtype.none.isNan(7, 2.5, NaN, 0, -5)                === false;
xtype.none.isBlankString('Tom', 0, true, null, ' ') === false;
xtype.none.isFloat(3, -5, 7)                        === true;
xtype.none.isFalse(true, true, false, true)         === false;
</content>




<content name="any_isType">
xtype.any.isNan(7, 2.5, NaN, 0, -5)                 === true;
xtype.any.isBlankString('Tom', 0, true, null, ' ')  === true;
xtype.any.isFloat(3, -5, 7)                         === false;
xtype.any.isFalse(true, true, false, true)          === true;
</content>




<content name="some_isType">
xtype.some.isFloat(7, 2.5, NaN, 0, -5)         === true;
xtype.some.isString('Tom', 0, true, null, ' ') === true;
xtype.some.isFloat(3, -5, 7)                   === false;
xtype.some.isInteger(3, -5, 7)                 === false; // All integer, not some
</content>




<content name="all_isType">
xtype.all.isFloat(7, 2.5, NaN, 0, -5)         === true;
xtype.all.isNonBlankString('hi', 'Tom', 'pi') === false;
xtype.all.isFloat(3.1, -5.5, 7)               === false;
xtype.all.isNonZeroNumber(3, -5, 7)           === true;
</content>




<content name="isType">
xtype.isSingleCharString('g')           === true;
xtype.isNonEmptyObject({foo: 'bar'})    === true;
xtype.isSingleElemArray(['foo'])        === true;

xtype.isFloat(2.50)                     === true;
xtype.isPositiveNumber(-2.5)            === false;
xtype.isNan(5 / 'hi')                   === true;
</content>




<content name="registerType">

/*
 * ---------------------------------------------------------------
 * REGISTER A DERIVED TYPE THAT MATCHES ALL OF THE COMPONENT TYPES
 * ---------------------------------------------------------------
 */

// To register a new type with name 'non_negative_integer', that validates
// when a data value matches both of the existing 'non_negative_number' and
// 'integer' types:

xtype.ext.registerType('non_negative_integer', {
    definition: 'non_negative_number, integer',
    matchMode: 'all'
});

xtype.isNonNegativeInteger(value);
xtype.is(value, 'non_negative_integer');


// To register a new type and also specify the corresponding names for the
// type in other name schemes, the 'schemeAliases' property can be used.
// For instance, to register the 'non_negative_integer' type also specifying
// '-int-' as the name of the type in the 'compact' name scheme:

xtype.ext.registerType('non_negative_integer', {
    definition: 'non_negative_number, integer',
    matchMode: 'all',
    schemeAliases: { compact: '-int-' }
});

xtype.isNonNegativeInteger(value);
xtype.is(value, '{@type:non_negative_integer:-int-}');


// The name of the new type can also be specified for several custom name
// schemes as part of the type registration. For instance, the following also
// specifies the type names for both the 'compact' and 'allcaps' name schemes:

xtype.ext.registerType('non_negative_integer', {
    definition: 'non_negative_number, integer',
    matchMode: 'all',
    schemeAliases: {
        compact: '-int-',
        allcaps: 'NON_NEGATIVE_INTEGER'
    }
});

/*
 * ---------------------------------------------------------------
 * REGISTER A DERIVED TYPE THAT MATCHES ANY OF THE COMPONENT TYPES
 * ---------------------------------------------------------------
 */

// To register a new type named 'flag' that validates when a data
// value is either a positive integer or a single character string:

xtype.ext.registerType('flag', {
    definition: 'positive_integer, single_char_string',
    // matchMode omitted because 'any' is the default
});

xtype.isFlag(value);
xtype.is(value, 'flag');


// But because only the 'definition' property is used in the 'flag'
// custom type registration above, it can be simplified to use the
// type expression string parameter format instead, which in this
// case accomplishes exactly the same thing:

xtype.ext.registerType('flag', 'positive_integer, single_char_string');


/*
 * ------------------------------
 * REGISTER A SELF-VALIDATED TYPE
 * ------------------------------
 */

// To register a type named 'social_security_number' that validates SSNs,
// and with 'ssn' as the name of the type in the 'compact' name scheme:

xtype.ext.registerType('social_security_number', {
    definition: {
        validator: function(val) {
            return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
        }
    },
    schemeAliases: { compact: 'ssn' }
});

xtype.isSocialSecurityNumber(value);
xtype.is(value, '{@type:social_security_number:ssn}');


// To register it simply with a single name 'ssn' as both the default name
// and name in any custom name schemes, then the registration can just be:

xtype.ext.registerType('ssn', {
    validator: function(val) {
        return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
    }
});

xtype.isSsn(value);
xtype.is(value, 'ssn');


/*
 * -------------------------
 * REGISTER AN INSTANCE TYPE
 * -------------------------
 */

// To register an instance type constructor function, Product,
// using the default name 'product' and with 'prod' as the name
// of the type in the 'compact' name scheme:

xtype.ext.registerType('product', {
    definition: Product,
    schemeAliases: { compact: 'prod' }
});

xtype.isProduct(value);
xtype.is(value, '{@type:product:prod}');


// To register it simply with a single name 'prod' as both the
// default name and name in any custom name schemes, then the
// simple function parameter format can be used:

xtype.ext.registerType('prod', Product);

xtype.isProd(value);
xtype.is(value, 'prod');


/*
 * -------------------------------
 * REGISTER MULTIPLE TYPES AT ONCE
 * -------------------------------
 */

xtype.ext.registerType({

    non_negative_integer: {                             // Derived type: match all
        definition: 'non_negative_number, integer',
        matchMode: 'all',
        schemeAliases: { compact: '-int-' }
    },
    
    social_security_number: {                           // Self-validated type
        definition: {
            validator: function(val) {
                return typeof val === 'string' && /^\d{3}-\d{2}-\d{4}$/.test(val);
            }
        },
        schemeAliases: { compact: 'ssn' }
    },
    
    flag: 'positive_integer, single_char_string',       // Derived type: match any
    
    product: Product                                    // Instance type
});

</content>




<content name="typeIdToName">
xtype.introspect.typeIdToName(xtype.POSITIVE_INTEGER) === '{positive_integer}';
</content>




<content name="typeNameToId">
xtype.introspect.typeNameToId('{positive_integer}') === xtype.POSITIVE_INTEGER;
</content>




<content name="typeComposition">
xtype.introspect.typeComposition('{blank_string}') === ['{empty_string}', '{whitespace}'];
</content>




<content name="typeDefaultName">
// When a name scheme other than the default scheme is active

xtype.setNameScheme('compact');
xtype(5) === 'int+';

// We can easily lookup the more descriptive default name
// scheme equivalent of a type in the active name scheme:

xtype.introspect.typeDefaultName('int+') === 'positive_integer';

// Useful for example, for a single value check,
// to get the more descriptive default name without
// switching out of the compact name scheme:

xtype.introspect.typeDefaultName(xtype(5)) === 'positive_integer';
</content>




<content name="typeFriendlyName">
xtype(5/'a') === '{nan}';
xtype('abc') === '{multi_char_string}';

// However:

xtype.introspect.typeFriendlyName(xtype(5/'a')) === 'not a number';
xtype.introspect.typeFriendlyName(xtype('abc')) === 'multiple character string';
</content>



</content-wrapper>


